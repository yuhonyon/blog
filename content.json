[{"title":"11","date":"2018-06-28T10:43:00.000Z","path":"2018/11/","text":"","tags":[]},{"title":"常用babel-plugin","date":"2018-05-03T17:36:00.000Z","path":"2018/常用babel-plugin/","text":"注意:presets是倒叙 plugins是正序 transform-function-bind 函数绑定’::’ 安装:1cnpm i babel-plugin-transform-function-bind -D 配置:1\"plugins\": [\"transform-function-bind\"] 例子:123456789101112131415obj::func// 相当于：func.bind(obj)::obj.func// 相当于：obj.func.bind(obj)obj::func(val)// 相当于：func.call(obj, val)::obj.func(val)// 相当于：obj.func.call(obj, val) transform-do-expressions 解析do{}表达式,主要应用jsx 安装:1cnpm i babel-plugin-transform-do-expressions -D 配置:1\"plugins\": [\"transform-do-expressions\"] 例子:12345678const Component = props =&gt; &lt;div className='myComponent'&gt; &#123;do &#123; if(color === 'blue') &#123; &lt;BlueComponent/&gt;; &#125; else if(color === 'red') &#123; &lt;RedComponent/&gt;; &#125; else if(color === 'green') &#123; &lt;GreenComponent/&gt;; &#125; &#125;&#125; &lt;/div&gt; transform-es2015-modules-commonjs 转es6 modules 为commonjs模式 安装:1cnpm i babel-plugin-transform-es2015-modules-commonjs -D 配置:1\"plugins\": [\"transform-es2015-modules-commonjs\"] transform-async-to-generator 解析async 安装:1cnpm i babel-plugin-transform-async-to-generator -D 配置:1\"plugins\": [\"transform-async-to-generator\"] transform-export-extensions 解析export-from 安装:1cnpm i babel-plugin-transform-export-extensions -D 配置:1\"plugins\": [\"transform-export-extensions\"] 例子:12export * as ns from 'mod';export v from 'mod'; transform-decorators-legacy 解析修饰器（Decorator） 安装:1cnpm i babel-plugin-transform-decorators-legacy -D 配置:1\"plugins\": [\"transform-decorators-legacy\"] transform-class-properties class 静态属性&amp;&amp;初始属性 安装:1cnpm i babel-plugin-transform-class-properties -D 配置:1\"plugins\": [\"transform-class-properties\"] 例子:123456789101112131415161718192021222324class Bork &#123; //Property initializer syntax instanceProperty = \"bork\"; boundFunction = () =&gt; &#123; return this.instanceProperty; &#125; //Static class properties static staticProperty = \"babelIsCool\"; static staticFunction = function() &#123; return Bork.staticProperty; &#125; &#125; let myBork = new Bork; //Property initializers are not on the prototype. console.log(myBork.prototype.boundFunction); // &gt; undefined //Bound functions are bound to the class instance. console.log(myBork.boundFunction.call(undefined)); // &gt; \"bork\" //Static function exists on the class. console.log(Bork.staticFunction()); // &gt; \"babelIsCool\"","tags":[]},{"title":"css网格单元布局","date":"2017-12-25T15:24:00.000Z","path":"2017/css网格单元布局/","text":"https://gridbyexample.com/examples/","tags":[]},{"title":"AppCache笔记","date":"2017-12-20T11:07:00.000Z","path":"2017/AppCache笔记/","text":"","tags":[]},{"title":"浏览器缓存机制","date":"2017-12-14T15:42:00.000Z","path":"2017/浏览器缓存机制/","text":"","tags":[]},{"title":"基于vue-cli配置脚手架","date":"2017-11-24T10:51:00.000Z","path":"2017/基于vue-cli配置脚手架/","text":"","tags":[]},{"title":"async-await笔记","date":"2017-11-23T16:04:00.000Z","path":"2017/async-await笔记/","text":"async-await:promise和generator的语法糖 错误处理使用try catch 之后我们就能够拿到 Promise.reject 回来的数据 12345678async function errorDemo() &#123; try &#123; let result = await outErrorFn(); console.log(result); &#125; catch (err) &#123; console.log(err); &#125;&#125; 并行处理1234567//错误,并发的请求变成了阻塞式同步的操作了async function bugDemo() &#123; await fetchApi(); await fetchApi(); await fetchApi(); console.log('清除loading');&#125; 1234567async function goodDemo() &#123; let p1= fetchApi(); let p2= fetchApi(); let p3= fetchApi(); await Promise.all([p1, p2, p3]); console.log('清除loading');&#125; for 循环await必须在async函数的上下文中的 123456async function forEachDemo() &#123; let arr = [1, 2, 3, 4, 5]; arr.forEach(item =&gt; &#123; await item;//报错,await不在async的上下文中 &#125;);&#125; 123456async function forDemo() &#123; let arr = [1, 2, 3, 4, 5]; for (let i = 0; i &lt; arr.length; i ++) &#123; await arr[i]; &#125;&#125;","tags":[]},{"title":"服务器管理","date":"2017-11-08T14:07:00.000Z","path":"2017/服务器管理/","text":"常用命令重装系统后链接ssh1ssh-keygen -R ip 开机启动12chmod +x /etc/rc.localvi /etc/rc.local 自动重启12crontab -e0 3 * * * sh /fs/restart.sh finalSpeed安装1wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/finalspeed/master/install_fs.sh &amp;&amp; bash install_fs.sh 命令 卸载：wget -N –no-check-certificate https://raw.githubusercontent.com/91yun/finalspeed/master/install_fs.sh &amp;&amp; bash install_fs.sh uninstall 操作：/etc/init.d/finalspeed {start|stop|status} 安装tcptun安装123wget --no-check-certificate -O ./kcptun_for_ss_ssr-install.sh https://raw.githubusercontent.com/onekeyshell/kcptun_for_ss_ssr/master/kcptun_for_ss_ssr-install.sh chmod 700 ./kcptun_for_ss_ssr-install.sh ./kcptun_for_ss_ssr-install.sh install ##更新1./kcptun_for_ss_ssr-install.sh update 卸载1./kcptun_for_ss_ssr-install.sh uninstall 命令/etc/init.d/{kcptun|ssr} {start|stop|restart|status|config|version}","tags":[]},{"title":"数据绑定Proxy VS Object.definProperty","date":"2017-10-16T11:32:00.000Z","path":"2017/数据绑定Proxy VS Object.definProperty/","text":"Object.definePropertyObject.defineProperty(obj, prop, descriptor) Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象 详情 参数obj需要被操作的目标对象 prop目标对象需要定义或修改的属性的名称。 descriptor将被定义或修改的属性的描述符。 返回值被传递给函数的对象。 1234567let aa=&#123;age:11&#125;Object.defineProperty(ironman, 'age', &#123; set (val) &#123; element.innerHTML=`这sb今年$&#123;age&#125;岁了` return val &#125;&#125;) 使用set()方法去监测属性变化，但是对于一个数组使用value()方法来代替 Proxyvar proxy = new Proxy(target, handler); Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。详情 参数target一个目标对象(可以是任何类型的对象，包括本机数组，函数，甚至另一个代理)用Proxy来包装。 handler一个对象，其属性是当执行一个操作时定义代理的行为的函数 12345678let aa=&#123;age:23&#125;let proxy = new Proxy(aa, &#123; set (target, property, value) &#123; target[property] = value element.innerHTML=`这sb今年$&#123;age&#125;岁了` return true &#125;&#125;) 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Vue&#123; constructor(options)&#123; this.$data=options.data; this.$el=options.el; this.$template=options.template; this._render(this.$template,this.$data) &#125; $setData (dataObj, fn) &#123; let self = this let once = false let $d = new Proxy(dataObj, &#123; set (target, property, value) &#123; if (!once) &#123; target[property] = value once = true self._render(self.$template, self.$data) &#125; return true &#125; &#125;) fn($d) &#125; _render (tplString, data) &#123; this.$el.innerHTML = this._replaceFun(tplString, data) &#125; _replaceFun(str, data) &#123; let self = this return str.replace(/&#123;&#123;([^&#123;&#125;]*)&#125;&#125;/g, (a, b) =&gt; &#123; let r = self._getObjProp(data, b); if (typeof r === 'string' || typeof r === 'number') &#123; return r &#125; else &#123; return self._getObjProp(r, b.split('.')[1]) &#125; &#125;) &#125; _getObjProp (obj, propsName) &#123; let propsArr = propsName.split('.') function rec(o, pName) &#123; if (!o[pName] instanceof Array &amp;&amp; o[pName] instanceof Object) &#123; return rec(o[pName], propsArr.shift()) &#125; return o[pName] &#125; return rec(obj, propsArr.shift()) &#125;&#125; 例子12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;p&gt;这sb今年&#123;&#123;age&#125;&#125;岁了&lt;/p&gt; &lt;input type=\"text\" id=\"input\"&gt;&lt;/div&gt;&lt;script&gt; let template=document.querySelector('#app').innerHTML let vue=new Vue(&#123; template:template, el:document.querySelector('#app'), data:&#123; age:24 &#125; &#125;) document.querySelector('#input').oninput = (e) =&gt; &#123; vue.$setData(vue.$data, ($d) =&gt; &#123; $d.age = e.target.value &#125;)&#125;&lt;/script&gt;","tags":[]},{"title":"glob","date":"2017-08-30T18:17:00.000Z","path":"2017/glob/","text":"测试是打发斯蒂芬","tags":[{"name":"gulp node","slug":"gulp-node","permalink":"http://blog.yfyld.online/tags/gulp-node/"}]},{"title":"ios 冒泡 bug","date":"2016-12-24T16:31:35.000Z","path":"iosBug1/","text":"问题123document.on('click','.aaa',function()&#123; //如果.aaa不是img a 的时候不触发&#125;); 在ios里点击事件,使用事件代理到 document 或body,不能触发 原因ios 系统bug 解决方案 给​目标元素加一条样式规则 {cursor: pointer}; 事件代理到body下面的容器","tags":[{"name":"ios","slug":"ios","permalink":"http://blog.yfyld.online/tags/ios/"}]},{"title":"markdown 语法","date":"2016-12-24T16:31:35.000Z","path":"canvasAPI/","text":"兼容HTML123456789//这是一个普通table。&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;//这是另一个普通table。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的强调会没有效果。 特殊字符自动转换14&lt;5 Markdown 将会把它转换为： 14 &amp;lt; 5 语法段落/换行在插入处先按入两个以上的空格然后回车 标题Markdown 支持两种标题的语法 用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果 在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：12345# 这是 H1## 这是 H2###### 这是 H6 引用在每行的最前面加上 &gt;Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt;引用的区块内也可以使用其他的 Markdown 语法 1234567&gt; ## 这是一个标题。&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 有序列表则使用数字接着一个英文句点: 1231. Bird2. McHale3. Parish 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 代码使用4个空格或者tab 这是一个普通段落： 这是一个代码区块。 或者使用反引号 分割线123456789* * *********- - ---------------------------------------- 链接Markdown中有两种方式，实现链接，分别为内联方式和引用方式。1234567内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ \"Google\" [2]: http://search.yahoo.com/ \"Yahoo Search\" [3]: http://search.msn.com/ \"MSN Search\" 内联方式：This is an example link.引用方式：I get 10 times more traffic from Google than from Yahoo or MSN. 自动链接1&lt;http://example.com/&gt; http://example.com/ 图片图片的处理方式和链接的处理方式，非常的类似。 12345内联方式：![alt text](https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png \"Title\")引用方式：![alt text][id] [id]: https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png \"Title\" 内联方式：引用方式： 强调Markdown 使用星号（）和底线（_）作为标记强调字词的符号，被 或 _ 包围的字词会被转成用 标签包围，用两个 * 或 _ 包起来的话，则会被转成 ，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线","tags":[{"name":"markdown","slug":"markdown","permalink":"http://blog.yfyld.online/tags/markdown/"}]},{"title":"markdown 语法1","date":"2016-12-24T16:31:35.000Z","path":"one/","text":"兼容HTML123456789//这是一个普通table。&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;//这是另一个普通table。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的强调会没有效果。 特殊字符自动转换14&lt;5 Markdown 将会把它转换为： 14 &amp;lt; 5 语法段落/换行在插入处先按入两个以上的空格然后回车 标题Markdown 支持两种标题的语法 用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：12345This is an H1=============This is an H2------------- 任何数量的 = 和 - 都可以有效果 在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：12345# 这是 H1## 这是 H2###### 这是 H6 引用在每行的最前面加上 &gt;Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt;引用的区块内也可以使用其他的 Markdown 语法 1234567&gt; ## 这是一个标题。&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 有序列表则使用数字接着一个英文句点: 1231. Bird2. McHale3. Parish 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 代码使用4个空格或者tab 这是一个普通段落： 这是一个代码区块。 或者使用反引号 分割线123456789* * *********- - ---------------------------------------- 链接Markdown中有两种方式，实现链接，分别为内联方式和引用方式。1234567内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].[1]: http://google.com/ \"Google\"[2]: http://search.yahoo.com/ \"Yahoo Search\"[3]: http://search.msn.com/ \"MSN Search\" 内联方式：This is an example link.引用方式：I get 10 times more traffic from Google than from Yahoo or MSN. 自动链接1&lt;http://example.com/&gt; http://example.com/ 图片图片的处理方式和链接的处理方式，非常的类似。 12345内联方式：![alt text](https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png \"Title\")引用方式：![alt text][id][id]: https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png \"Title\" 内联方式：引用方式： 强调Markdown 使用星号（）和底线（_）作为标记强调字词的符号，被 或 _ 包围的字词会被转成用 标签包围，用两个 * 或 _ 包起来的话，则会被转成 ，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。如果要在文字前后直接插入普通的星号或底线，你可以用反斜线","tags":[{"name":"markdown","slug":"markdown","permalink":"http://blog.yfyld.online/tags/markdown/"}]},{"title":"markdown 语法","date":"2016-12-14T16:31:35.000Z","path":"canvasDemo/","text":"1&lt;canvas id=\"canvas\" width=\"100\" height=\"100\"&gt;该浏览器不支持canvas&lt;/canvas&gt; 没有设置width,heightcanvas会初始化宽度为300像素和高度为150像素。 使用CSS设置宽高,canvas会伸缩(类似&lt;img&gt;) &lt;canvas&gt;标签中提供了替换内容。支持&lt;canvas&gt;的浏览器将会忽略在容器中包含的内容，并且只是正常渲染canvas。 Context2d渲染上下文方式12var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d'); 绘制API矩形123456CanvasRenderingContext2D.fillRect(x, y, width, height)//绘制一个填充的矩形CanvasRenderingContext2D.strokeRect(x, y, width, height)//绘制一个矩形的边框CanvasRenderingContext2D.clearRect(x, y, width, height)//清除指定矩形区域，让清除部分完全透明。 路径123456789101112131415161718192021222324CanvasRenderingContext2D.beginPath()//新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。CanvasRenderingContext2D.closePath()//闭合路径之后图形绘制命令又重新指向到上下文中。CanvasRenderingContext2D.moveTo()//将一个新的子路径的起始点移动到(x，y)坐标。CanvasRenderingContext2D.lineTo()//使用直线连接子路径的最后的点到x,y坐标。CanvasRenderingContext2D.bezierCurveTo()//添加一个3次贝赛尔曲线路径。该方法需要三个点。 第一、第二个点是控制点，第三个点是结束点。起始点是当前路径的最后一个点，绘制贝赛尔曲线前，可以通过调用 moveTo() 进行修改。CanvasRenderingContext2D.quadraticCurveTo()//添加一个2次贝赛尔曲线路径。CanvasRenderingContext2D.arc()//绘制一段圆弧路径， 圆弧路径的圆心在 (x, y) 位置，半径为 r ，根据anticlockwise （默认为顺时针）指定的方向从 startAngle 开始绘制，到 endAngle 结束。CanvasRenderingContext2D.arcTo()//根据控制点和半径绘制圆弧路径，使用直线连接前一个点。CanvasRenderingContext2D.ellipse() //添加一个椭圆路径，椭圆的圆心在（x,y）位置，半径分别是radiusX 和 radiusY ，按照anticlockwise （默认顺时针）指定的方向，从 startAngle 开始绘制，到 endAngle 结束。CanvasRenderingContext2D.rect()//创建一个矩形路径，矩形的起点位置是 (x, y) ，尺寸为 width 和 height。CanvasRenderingContext2D.stroke()//通过线条来绘制图形轮廓。CanvasRenderingContext2D.fill()//通过填充路径的内容区域生成实心的图形。 文本123456CanvasRenderingContext2D.fillText()//在(x,y)位置绘制（填充）文本。CanvasRenderingContext2D.strokeText()//在(x,y)位置绘制（描边）文本。CanvasRenderingContext2D.measureText()//返回 TextMetrics 对象。 图片12CanvasRenderingContext2D.drawImage()//绘制指定的图片。该方法有多种格式，提供了很大的使用灵活性。 样式API线样式1234567891011121314CanvasRenderingContext2D.lineWidth线的宽度。默认 1.0CanvasRenderingContext2D.lineCap线末端的类型。 允许的值： butt (默认), round, square.CanvasRenderingContext2D.lineJoin定义两线相交拐点的类型。允许的值：round, bevel, miter(默认)。CanvasRenderingContext2D.miterLimit斜接面限制比例。默认 10。CanvasRenderingContext2D.getLineDash()返回当前线段样式的数组，数组包含一组数量为偶数的非负数数字。CanvasRenderingContext2D.setLineDash()设置当前的线段样式。CanvasRenderingContext2D.lineDashOffset描述在哪里开始绘制线段。 文本样式12345678CanvasRenderingContext2D.font字体设置。 默认值 10px sans-serif。CanvasRenderingContext2D.textAlign文本对齐设置。 允许的值： start (默认), end, left, right 或 center.CanvasRenderingContext2D.textBaseline基线对齐设置。 允许的值： top, hanging, middle, alphabetic (默认),ideographic, bottom.CanvasRenderingContext2D.direction文本的方向。 允许的值： ltr, rtl, inherit (默认). 填充,描边,渐变,图案12345678910CanvasRenderingContext2D.fillStyle//图形内部的颜色和样式。 默认 #000 (黑色).CanvasRenderingContext2D.strokeStyle//图形边线的颜色和样式。 默认 #000 (黑色)CanvasRenderingContext2D.createLinearGradient()//创建一个沿着参数坐标指定的线的线性渐变。CanvasRenderingContext2D.createRadialGradient()//创建一个沿着参数坐标指定的线的放射性性渐变。CanvasRenderingContext2D.createPattern()//使用指定的图片 (CanvasImageSource)创建图案。通过 repetition 变量指定的方向上重复源图片。此方法返回 CanvasPattern对象。 阴影12345678CanvasRenderingContext2D.shadowBlur//描述模糊效果。 默认 0CanvasRenderingContext2D.shadowColor//阴影的颜色。 默认fully-transparent black.CanvasRenderingContext2D.shadowOffsetX//阴影水平方向的偏移量。 默认 0.CanvasRenderingContext2D.shadowOffsetY//阴影垂直方向的偏移量。 默认 0. 方法APIcanvas状态123456CanvasRenderingContext2D.save()//使用栈保存当前的绘画样式状态，你可以使用 restore() 恢复任何改变。CanvasRenderingContext2D.restore()//恢复到最近的绘制样式状态，此状态是通过 save() 保存到”状态栈“中最新的元素。CanvasRenderingContext2D.canvas//对 HTMLCanvasElement 只读的反向引用。如果和 &lt;canvas&gt; 元素没有联系，可能为null。 路径12345678910CanvasRenderingContext2D.drawFocusIfNeeded()如果给定的元素获取了焦点，那么此方法会在当前的路径绘制一个焦点。CanvasRenderingContext2D.scrollPathIntoView()将当前或给定的路径滚动到窗口。CanvasRenderingContext2D.clip()从当前路径创建一个剪切路径。在 clip() 调用之后，绘制的所有信息只会出现在剪切路径内部。CanvasRenderingContext2D.isPointInPath()判断当前路径是否包含检测点。CanvasRenderingContext2D.isPointInStroke()判断检测点是否在路径的描边线上。 变换在 CanvasRenderingContext2D 渲染背景中的对象会有一个当前的变换矩阵，一些方法可以对其进行控制。当创建当前的默认路径，绘制文本、图形和Path2D对象的时候，会应用此变换矩阵。1234567891011121314CanvasRenderingContext2D.currentTransform//当前的变换矩阵 (SVGMatrix 对象)。CanvasRenderingContext2D.rotate()//在变换矩阵中增加旋转，角度变量表示一个顺时针旋转角度并且用弧度表示。CanvasRenderingContext2D.scale()//根据 x 水平方向和 y 垂直方向，为canvas 单位添加缩放变换。CanvasRenderingContext2D.translate()//通过在网格中移动 canvas 和 canvas 原点 x 水平方向、原点 y 垂直方向，添加平移变换CanvasRenderingContext2D.transform()//使用方法参数描述的矩阵多次叠加当前的变换矩阵。CanvasRenderingContext2D.setTransform()//重新设置当前的变换为单位矩阵，并使用同样的变量调用 transform() 方法。CanvasRenderingContext2D.resetTransform() //使用单位矩阵重新设置当前的变换。 像素控制123456CanvasRenderingContext2D.createImageData()//使用指定的尺寸，创建一个新的、空白的 ImageData 对象。所有的像素在新对象中都是透明的。CanvasRenderingContext2D.getImageData()//返回一个 ImageData 对象，用来描述canvas区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh。CanvasRenderingContext2D.putImageData()//将数据从已有的 ImageData 绘制到位图上。 如果提供了脏矩形，只能绘制矩形的像素。 图像12CanvasRenderingContext2D.imageSmoothingEnabled 图像平滑的方式；如果禁用，缩放时，图像不会被平滑处理。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://blog.yfyld.online/tags/markdown/"}]},{"title":"markdown 语法","date":"2016-12-14T16:31:35.000Z","path":"markdown/","text":"Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。","tags":[{"name":"markdown","slug":"markdown","permalink":"http://blog.yfyld.online/tags/markdown/"}]}]